from __future__ import annotations

from typing import Any, Dict, List, Optional, Protocol, Sequence, Mapping, runtime_checkable

try:
    # keep compatibility with your existing alias
    from ttkbootstrap_next.types import Primitive  # type: ignore
except Exception:
    Primitive = Any

Record = Dict[str, Any]


@runtime_checkable
class DataSourceProtocol(Protocol):
    # public attrs
    page_size: int

    # ---------- data & view config ----------
    def set_data(self, records: Sequence[Primitive] | Sequence[Mapping[str, Any]]) -> "DataSourceProtocol": ...

    def set_filter(self, where_sql: str = "") -> None: ...

    def set_sort(self, order_by_sql: str = "") -> None: ...

    # ---------- pagination ----------
    def get_page(self, page: Optional[int] = None) -> List[Record]: ...

    def next_page(self) -> List[Record]: ...

    def prev_page(self) -> List[Record]: ...

    def has_next_page(self) -> bool: ...

    def total_count(self) -> int: ...

    # ---------- CRUD ----------
    def create_record(self, record: Dict[str, Any]) -> int: ...

    def read_record(self, record_id: Any) -> Optional[Record]: ...

    def update_record(self, record_id: Any, updates: Dict[str, Any]) -> bool: ...

    def delete_record(self, record_id: Any) -> bool: ...

    # ---------- selection ----------
    def select_record(self, record_id: Any) -> bool: ...

    def unselect_record(self, record_id: Any) -> bool: ...

    def select_all(self, current_page_only: bool = False) -> int: ...

    def unselect_all(self, current_page_only: bool = False) -> int: ...

    def get_selected(self, page: Optional[int] = None) -> List[Record]: ...

    def selected_count(self) -> int: ...

    # ---------- export ----------
    def export_to_csv(self, filepath: str, include_all: bool = True) -> None: ...

    # ---------- index-based paging ----------
    def get_page_from_index(self, start_index: int, count: int) -> List[Record]: ...
